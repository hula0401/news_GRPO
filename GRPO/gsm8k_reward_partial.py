"""
Custom GSM8K reward function with partial credit scoring.

This reward function provides less sparse rewards by giving partial credit for:
- Exact answer match: +1.0
- Numeric value match (ignoring format): +0.3
- Valid format with #### marker: +0.1
- Length penalty for rambling: -0.05 per excessive 100 chars

This helps GRPO learn gradients earlier in training compared to binary 0/1 rewards.
"""

from __future__ import annotations

import re
from typing import Any, Dict, Optional

_SOLUTION_CLIP_CHARS = 300
_MAX_REASONABLE_LENGTH = 500  # Threshold for length penalty


def _extract_solution(solution_str: str, method: str = "strict") -> Optional[str]:
    """
    Extract the final numeric answer from the model output.

    Parameters
    ----------
    solution_str :
        The full text generated by the model.
    method :
        Extraction mode. If "strict", require a pattern like
        "#### 72". If "flexible", return the last numeric token.

    Returns
    -------
    Optional[str]
        The extracted answer string without commas or "$", or
        None if no valid answer is found.
    """
    assert method in {"strict", "flexible"}

    text = solution_str
    if len(text) > _SOLUTION_CLIP_CHARS:
        text = text[-_SOLUTION_CLIP_CHARS :]

    if method == "strict":
        # Look for: #### -123.45
        matches = re.findall(r"#### (\-?[0-9\.,]+)", text)
        if not matches:
            return None
        final = matches[-1]
        return final.replace(",", "").replace("$", "")

    # Flexible: take the last reasonable number in the text
    candidates = re.findall(r"(\-?[0-9\.,]+)", text)
    if not candidates:
        return None

    invalid = {"", "."}
    for candidate in reversed(candidates):
        if candidate not in invalid:
            return candidate.replace(",", "").replace("$", "")

    return None


def _normalize_number(num_str: str) -> Optional[float]:
    """
    Convert a numeric string to float for comparison.

    Parameters
    ----------
    num_str :
        String representation of a number (e.g., "72", "3.14", "-5")

    Returns
    -------
    Optional[float]
        Parsed float value, or None if parsing fails
    """
    try:
        return float(num_str.replace(",", "").replace("$", ""))
    except (ValueError, AttributeError):
        return None


def _has_valid_format(solution_str: str) -> bool:
    """
    Check if the solution uses the expected #### format.

    Parameters
    ----------
    solution_str :
        The model-generated solution text

    Returns
    -------
    bool
        True if solution contains "####" marker
    """
    return "####" in solution_str


def _compute_length_penalty(solution_str: str) -> float:
    """
    Compute penalty for excessively long responses (rambling).

    Parameters
    ----------
    solution_str :
        The model-generated solution text

    Returns
    -------
    float
        Penalty value (0.0 or negative)
    """
    length = len(solution_str)
    if length <= _MAX_REASONABLE_LENGTH:
        return 0.0

    # Penalize 0.05 for every 100 chars beyond threshold
    excess_chars = length - _MAX_REASONABLE_LENGTH
    penalty = -(excess_chars // 100) * 0.05

    # Cap penalty at -0.5 to avoid overwhelming other signals
    return max(penalty, -0.5)


def compute_score(
    data_source: str,
    solution_str: str,
    ground_truth: str,
    extra_info: Optional[Dict[str, Any]] = None,
) -> float:
    """
    Compute a scalar reward with partial credit for GSM8K.

    Reward structure:
    - Exact match: +1.0
    - Numeric value matches (ignoring format): +0.3
    - Valid format with #### marker: +0.1
    - Length penalty for rambling: -0.05 per 100 chars beyond threshold

    Parameters
    ----------
    data_source :
        Name of the dataset. Ignored here but required by the API.
    solution_str :
        The model-generated solution text.
    ground_truth :
        The ground truth numeric answer, e.g. "72".
    extra_info :
        Optional extra fields from the DataProto. Unused.

    Returns
    -------
    float
        Reward in [-0.5, 1.0]. Higher is better.
    """
    _ = data_source
    _ = extra_info

    reward = 0.0

    # Extract answer using strict method (requires #### format)
    answer = _extract_solution(solution_str=solution_str, method="strict")

    # Check for exact match (+1.0)
    if answer is not None and answer == ground_truth:
        return 1.0

    # Check for numeric value match (+0.3)
    if answer is not None:
        answer_num = _normalize_number(answer)
        gt_num = _normalize_number(ground_truth)

        if answer_num is not None and gt_num is not None:
            # Allow small floating point tolerance
            if abs(answer_num - gt_num) < 1e-6:
                reward += 0.3

    # Check for valid format (+0.1)
    if _has_valid_format(solution_str):
        reward += 0.1

    # Apply length penalty
    #length_penalty = _compute_length_penalty(solution_str)
    #reward += length_penalty

    return reward
