"""
Custom GSM8K reward function compatible with verl's RewardManager.

This module defines a single entrypoint function `compute_score` that
verl will call when `custom_reward_function.path` points here.
"""

from __future__ import annotations

import re
import logging
from typing import Any, Dict, Optional

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

_SOLUTION_CLIP_CHARS = 300
_LOG_SAMPLE_RATE = 10  # Log every 10th example to avoid spam


def _extract_solution(solution_str: str, method: str = "strict") -> Optional[str]:
    """
    Extract the final numeric answer from the model output.

    Parameters
    ----------
    solution_str :
        The full text generated by the model.
    method :
        Extraction mode. If "strict", require a pattern like
        "#### 72". If "flexible", return the last numeric token.

    Returns
    -------
    Optional[str]
        The extracted answer string without commas or "$", or
        None if no valid answer is found.
    """
    assert method in {"strict", "flexible"}

    text = solution_str
    if len(text) > _SOLUTION_CLIP_CHARS:
        text = text[-_SOLUTION_CLIP_CHARS :]

    if method == "strict":
        # Look for: #### -123.45
        matches = re.findall(r"#### (\-?[0-9\.,]+)", text)
        if not matches:
            return None
        final = matches[-1]
        return final.replace(",", "").replace("$", "")

    # Flexible: take the last reasonable number in the text
    candidates = re.findall(r"(\-?[0-9\.,]+)", text)
    if not candidates:
        return None

    invalid = {"", "."}
    for candidate in reversed(candidates):
        if candidate not in invalid:
            return candidate.replace(",", "").replace("$", "")

    return None


# Global counter for sampling logs
_call_counter = 0


def compute_score(
    data_source: str,
    solution_str: str,
    ground_truth: str,
    extra_info: Optional[Dict[str, Any]] = None,
) -> float:
    """
    Compute a scalar reward for a single GSM8K example.

    This function matches verl's expected signature for custom reward
    functions. It returns 1.0 for correct answers, -1.0 for incorrect
    answers, and 0.0 for no answer extracted.

    Parameters
    ----------
    data_source :
        Name of the dataset. Ignored here but required by the API.
    solution_str :
        The model-generated solution text.
    ground_truth :
        The ground truth numeric answer, e.g. "72".
    extra_info :
        Optional extra fields from the DataProto. Unused.

    Returns
    -------
    float
        Reward in [-1.0, 1.0]. 1.0 if exact match, -1.0 if mismatch,
        0.0 if no answer extracted.
    """
    global _call_counter
    _call_counter += 1

    _ = data_source

    answer = _extract_solution(solution_str=solution_str, method="strict")

    # Compute reward
    if answer is None:
        reward = 0.0
        match_status = "NO_ANSWER_EXTRACTED"
    elif answer == ground_truth:
        reward = 1.0
        match_status = "EXACT_MATCH"
    else:
        reward = -1.0
        match_status = "MISMATCH"

    # Log every Nth example to debug reward issues
    if _call_counter % _LOG_SAMPLE_RATE == 0:
        logger.info("=" * 80)
        logger.info(f"Reward Sample #{_call_counter}")
        logger.info(f"Ground Truth: {ground_truth}")
        logger.info(f"Extracted Answer: {answer}")
        logger.info(f"Match Status: {match_status}")
        logger.info(f"Reward: {reward}")
        logger.info(f"Model Output (last 200 chars): ...{solution_str[-200:]}")
        logger.info("=" * 80)

    return reward
